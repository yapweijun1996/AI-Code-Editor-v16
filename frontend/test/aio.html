<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>AIO Test - Automated Tool Suite</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;margin:0;padding:16px;background:#0b0f17;color:#e6edf3}
    h1{margin:0 0 12px 0;font-size:20px}
    .controls{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:12px}
    button{background:#238636;border:0;color:#fff;padding:8px 12px;border-radius:6px;cursor:pointer}
    button.secondary{background:#30363d}
    button:disabled{opacity:.6;cursor:not-allowed}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    .panel{background:#0d1117;border:1px solid #30363d;border-radius:8px;padding:12px}
    .log{background:#0d1117;border:1px solid #30363d;border-radius:6px;padding:8px;height:320px;overflow:auto;font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;font-size:12px;white-space:pre-wrap}
    .status{display:flex;gap:8px;margin-bottom:8px;align-items:center}
    .badge{padding:2px 6px;border-radius:999px;border:1px solid #30363d;background:#161b22;font-size:11px}
    .pass{color:#3fb950}
    .fail{color:#f85149}
    .warn{color:#d29922}
    .summary{margin-top:12px}
    a{color:#58a6ff}
  </style>
  <script defer src="../js/tool_executor.js"></script>
</head>
<body>
  <h1>AIO Test - Automated Tool Suite</h1>
  <div class="controls">
    <button id="selectDirBtn">Select Directory (required for FS tests)</button>
    <button id="runBtn" class="secondary">Run All Tests</button>
    <button id="stopBtn" class="secondary">Stop</button>
  </div>
  <div class="grid">
    <section class="panel">
      <div class="status">
        <span class="badge">Backend</span>
        <span id="backendStatus">Idle</span>
      </div>
      <div id="backendLog" class="log"></div>
    </section>
    <section class="panel">
      <div class="status">
        <span class="badge">Frontend FS</span>
        <span id="fsStatus">Idle</span>
      </div>
      <div id="fsLog" class="log"></div>
    </section>
  </div>
  <section class="panel summary">
    <div class="status">
      <span class="badge">Summary</span>
      <span id="summaryText">No runs yet.</span>
    </div>
    <div>Tip: Open the <a href="./index.html" target="_blank" rel="noopener">Test Hub</a> in another tab.</div>
  </section>

<script>
(function(){
  const el = s => document.querySelector(s);
  const backendLog = el('#backendLog');
  const fsLog = el('#fsLog');
  const backendStatus = el('#backendStatus');
  const fsStatus = el('#fsStatus');
  const runBtn = el('#runBtn');
  const stopBtn = el('#stopBtn');
  const selectDirBtn = el('#selectDirBtn');
  const summaryText = el('#summaryText');

  let abort = false;
  let rootDirHandle = null;

  function log(target, msg) {
    const time = new Date().toISOString().split('T')[1].replace('Z','');
    target.textContent += '[' + time + '] ' + msg + '\n';
    target.scrollTop = target.scrollHeight;
  }
  function setStatus(elm, text, cls) {
    elm.textContent = text;
    elm.classList.remove('pass','fail','warn');
    if (cls) elm.classList.add(cls);
  }
  async function postJSON(url, body) {
    const res = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body||{})
    });
    const data = await res.json().catch(()=> ({}));
    return { status: res.status, ok: res.ok, data };
  }

  // Enhanced request helper with detailed logging
  async function requestWithLogging(name, url, body, targetLog) {
    const payloadStr = JSON.stringify(body);
    log(targetLog, `---> ${name}`);
    log(targetLog, `     Payload: ${payloadStr}`);
    let res, data, status, ok;
    try {
      res = await fetch(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: payloadStr
      });
      status = `${res.status} ${res.statusText || ''}`.trim();
      ok = res.ok;
      try {
        data = await res.json();
      } catch {
        data = {};
      }
      log(targetLog, `     Response: ${status}`);
      return { ok, statusCode: res.status, data, raw: res };
    } catch (err) {
      log(targetLog, `     Network Error: ${err.message}`);
    }
    return { ok: false, statusCode: 0, data: { error: 'network_failure' } };
  }

  function previewJSON(obj, max = 800) {
    try {
      const s = JSON.stringify(obj, null, 2);
      return s.length > max ? s.slice(0, max) + '…' : s;
    } catch {
      return String(obj);
    }
  }
 
  // Backend helper: get_project_structure via /api/execute-tool
  async function beGetProjectStructure(logTarget) {
    const body = { toolName: 'get_project_structure', parameters: {} };
    const r = await requestWithLogging('get_project_structure', '/api/execute-tool', body, logTarget || backendLog);
    // Accept either { structure: '...' } or raw object with text/lines
    const s = (r.data && (r.data.structure || r.data.text)) || JSON.stringify(r.data || {});
    return { ok: r.ok, text: String(s || '') };
  }
 
   // Path utilities with FS Access API
   async function getHandleForPath(root, path, { createDir } = { createDir: false }) {
    const parts = path.split('/').filter(Boolean);
    let dir = root;
    for (let i=0;i<parts.length-1;i++) {
      const segment = parts[i];
      try {
        dir = await dir.getDirectoryHandle(segment, { create: createDir });
      } catch (e) {
        throw new Error('Directory not found: ' + segment + ' in ' + path);
      }
    }
    const name = parts[parts.length-1];
    return { dir, name };
  }
  async function ensureFile(root, path) {
    const { dir, name } = await getHandleForPath(root, path, { createDir: true });
    return await dir.getFileHandle(name, { create: true });
  }
  async function getExistingFile(root, path) {
    const { dir, name } = await getHandleForPath(root, path, { createDir: false });
    return await dir.getFileHandle(name, { create: false });
  }
  async function writeFile(handle, content) {
    const ws = await handle.createWritable();
    await ws.write(content);
    await ws.close();
  }
  async function readFileText(handle) {
    const file = await handle.getFile();
    return await file.text();
  }
  async function removeEntry(root, path) {
    const { dir, name } = await getHandleForPath(root, path, { createDir: false });
    await dir.removeEntry(name, { recursive: false });
  }
  async function renameFile(root, oldPath, newPath) {
    // Copy + delete approach
    const src = await getExistingFile(root, oldPath);
    const srcText = await readFileText(src);
    const dstHandle = await ensureFile(root, newPath);
    await writeFile(dstHandle, srcText);
    await removeEntry(root, oldPath);
  }
  async function exists(root, path) {
    try {
      await getExistingFile(root, path);
      return true;
    } catch {
      return false;
    }
  }
  async function listDir(root, path) {
    const parts = path ? path.split('/').filter(Boolean) : [];
    let dir = root;
    for (const p of parts) {
      dir = await dir.getDirectoryHandle(p, { create: false });
    }
    const entries = [];
    for await (const [name, handle] of dir.entries()) {
      entries.push({ name, kind: handle.kind });
    }
    return entries;
  }

  async function runBackendTests() {
    setStatus(backendStatus, 'Running...', 'warn');
    backendLog.textContent = '';
    let pass = 0, fail = 0;
    // duckduckgo_search
    try {
      const body = { query: 'example domain' };
      const r = await requestWithLogging('duckduckgo_search', '/api/duckduckgo-search', body, backendLog);
      const hasResults = r.ok && Array.isArray(r.data.results) && r.data.results.length > 0;
      log(backendLog, '     Assert: results array exists and length > 0');
      if (!hasResults) {
        log(backendLog, '     FAIL details: ' + previewJSON(r.data));
        throw new Error('unexpected response');
      }
      log(backendLog, 'duckduckgo_search PASS');
      pass++;
    } catch (e) {
      log(backendLog, 'duckduckgo_search FAIL: ' + e.message);
      fail++;
    }
    if (abort) return { pass, fail };
    // read_url
    try {
      const body = { url: 'https://example.com' };
      const r = await requestWithLogging('read_url', '/api/read-url', body, backendLog);
      const text = (r.data && (r.data.text || r.data.content || '')) || '';
      log(backendLog, '     Assert: response contains "Example Domain"');
      if (!r.ok || !/Example Domain/i.test(text)) {
        log(backendLog, '     FAIL details: ' + previewJSON(r.data));
        throw new Error('content check failed');
      }
      log(backendLog, 'read_url PASS');
      pass++;
    } catch (e) {
      log(backendLog, 'read_url FAIL: ' + e.message);
      fail++;
    }
    if (abort) return { pass, fail };
    // run_terminal_command
    try {
      const body = { toolName: 'run_terminal_command', parameters: { command: 'echo AIO_OK' } };
      const r = await requestWithLogging('run_terminal_command', '/api/execute-tool', body, backendLog);
      const out = (r.data && (r.data.stdout || r.data.output || '')) || '';
      log(backendLog, '     Assert: stdout contains "AIO_OK"');
      if (!r.ok || !/AIO_OK/.test(out)) {
        log(backendLog, '     FAIL details: ' + previewJSON(r.data));
        throw new Error('output mismatch');
      }
      log(backendLog, 'run_terminal_command PASS');
      pass++;
    } catch (e) {
      log(backendLog, 'run_terminal_command FAIL: ' + e.message);
      fail++;
    }
    if (abort) return { pass, fail };
    // get_file_history
    try {
      const body = { toolName: 'get_file_history', parameters: { path: 'backend/index.js' } };
      const r = await requestWithLogging('get_file_history', '/api/execute-tool', body, backendLog);
      const output = (r.data && (r.data.stdout || r.data.output)) || '';
      log(backendLog, '     Assert: non-empty git log output');
      if (!r.ok || !output || !output.trim()) {
        log(backendLog, '     FAIL details: ' + previewJSON(r.data));
        throw new Error('no data');
      }
      // Show a short preview of first line for context
      const firstLine = String(output).split('\n')[0] || '';
      log(backendLog, '     Preview: ' + firstLine.slice(0, 160));
      log(backendLog, 'get_file_history PASS');
      pass++;
    } catch (e) {
      log(backendLog, 'get_file_history FAIL: ' + e.message);
      fail++;
    }
    if (abort) return { pass, fail };

    // FOLDER OPS (Backend): create_folder, rename_folder, delete_folder with assertions
    try {
      const base = 'aio-test-folders';
      const unique = '.aio-f-' + Date.now();
      const p1 = base + '/' + unique;
      const p2 = base + '/' + unique + '-renamed';

      // Ensure base exists (ignore failure)
      await requestWithLogging('create_folder (base)', '/api/execute-tool',
        { toolName: 'create_folder', parameters: { path: base } }, backendLog);

      // create_folder p1
      const rCreate = await requestWithLogging('create_folder', '/api/execute-tool',
        { toolName: 'create_folder', parameters: { path: p1 } }, backendLog);
      if (!rCreate.ok) throw new Error('create_folder failed');

      // assert p1 exists
      const s1 = await beGetProjectStructure(backendLog);
      log(backendLog, '     Assert: project structure contains ' + p1);
      if (!s1.ok || !new RegExp('(^|[\\n\\r\\/])' + p1.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\$&') + '(\\/|\\n|\\r|$)').test(s1.text)) {
        log(backendLog, '     FAIL details (structure preview): ' + s1.text.slice(0, 240));
        throw new Error('create assertion failed');
      }

      // rename_folder p1 -> p2
      const rRename = await requestWithLogging('rename_folder', '/api/execute-tool',
        { toolName: 'rename_folder', parameters: { oldPath: p1, newPath: p2 } }, backendLog);
      if (!rRename.ok) throw new Error('rename_folder failed');

      // assert p1 gone, p2 exists
      const s2 = await beGetProjectStructure(backendLog);
      const hasP1 = new RegExp('(^|[\\n\\r\\/])' + p1.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\$&') + '(\\/|\\n|\\r|$)').test(s2.text);
      const hasP2 = new RegExp('(^|[\\n\\r\\/])' + p2.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\$&') + '(\\/|\\n|\\r|$)').test(s2.text);
      log(backendLog, '     Assert: old not found, new found');
      if (hasP1 || !hasP2) {
        log(backendLog, '     FAIL details (structure preview): ' + s2.text.slice(0, 240));
        throw new Error('rename assertion failed');
      }

      // delete_folder p2
      const rDelete = await requestWithLogging('delete_folder', '/api/execute-tool',
        { toolName: 'delete_folder', parameters: { path: p2 } }, backendLog);
      if (!rDelete.ok) throw new Error('delete_folder failed');

      // assert p2 gone
      const s3 = await beGetProjectStructure(backendLog);
      const stillP2 = new RegExp('(^|[\\n\\r\\/])' + p2.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\$&') + '(\\/|\\n|\\r|$)').test(s3.text);
      log(backendLog, '     Assert: deleted path not present');
      if (stillP2) {
        log(backendLog, '     FAIL details (structure preview): ' + s3.text.slice(0, 240));
        throw new Error('delete assertion failed');
      }

      log(backendLog, 'folder_ops (backend) PASS');
      pass++;
    } catch (e) {
      log(backendLog, 'folder_ops (backend) FAIL: ' + e.message);
      fail++;
    }

    setStatus(backendStatus, fail ? ('Failed ('+fail+')') : 'Passed', fail ? 'fail' : 'pass');
    return { pass, fail };
  }

  async function runFsTests() {
    setStatus(fsStatus, 'Running...', 'warn');
    fsLog.textContent = '';
    if (!rootDirHandle) {
      log(fsLog, 'No directory selected. Click "Select Directory".');
      setStatus(fsStatus, 'Needs Directory', 'warn');
      return { pass: 0, fail: 1 };
    }
    let pass = 0, fail = 0;
    const testFile = 'aio-test/.aio-test-file.tmp';
    const renamedFile = 'aio-test/.aio-test-file.renamed';
    const content = 'AIO FILE TEST\nLINE 1\nLINE 2\nLINE 3';
    // ensure folder
    try {
      await ensureFile(rootDirHandle, testFile);
      log(fsLog, 'Created file: ' + testFile);
      pass++;
    } catch (e) {
      log(fsLog, 'Create FAIL: ' + e.message);
      fail++;
    }
    if (abort) return { pass, fail };
    // write
    try {
      const fh = await getExistingFile(rootDirHandle, testFile);
      await writeFile(fh, content);
      log(fsLog, 'Write PASS');
      pass++;
    } catch (e) {
      log(fsLog, 'Write FAIL: ' + e.message);
      fail++;
    }
    if (abort) return { pass, fail };
    // list
    try {
      const entries = await listDir(rootDirHandle, 'aio-test');
      const names = entries.map(e=>e.name);
      if (!names.includes('.aio-test-file.tmp')) throw new Error('file not found in list');
      log(fsLog, 'List PASS (' + names.join(', ') + ')');
      pass++;
    } catch (e) {
      log(fsLog, 'List FAIL: ' + e.message);
      fail++;
    }
    if (abort) return { pass, fail };
    // read
     try {
      const fh = await getExistingFile(rootDirHandle, testFile);
      const txt = await readFileText(fh);
      if (!/AIO FILE TEST/.test(txt)) throw new Error('read content mismatch');
      log(fsLog, 'Read PASS');
      pass++;
    } catch (e) {
      log(fsLog, 'Read FAIL: ' + e.message);
      fail++;
    }
    if (abort) return { pass, fail };
    // search_in_file (regex)
    try {
      const fh = await getExistingFile(rootDirHandle, testFile);
      const txt = await readFileText(fh);
      const re = /LINE\s+2/;
      const matched = re.test(txt);
      if (!matched) throw new Error('pattern not found');
      log(fsLog, 'Search PASS (regex /LINE\\s+2/)');
      pass++;
    } catch (e) {
      log(fsLog, 'Search FAIL: ' + e.message);
      fail++;
    }
    if (abort) return { pass, fail };
    // read_file_lines
    try {
      const fh = await getExistingFile(rootDirHandle, testFile);
      const txt = await readFileText(fh);
      const lines = txt.split(/\r?\n/);
      const slice = lines.slice(1,3).join('\n');
      if (!/LINE 1\nLINE 2/.test(slice)) throw new Error('slice mismatch');
      log(fsLog, 'Read Lines PASS (2 lines)');
      pass++;
    } catch (e) {
      log(fsLog, 'Read Lines FAIL: ' + e.message);
      fail++;
    }
    if (abort) return { pass, fail };
    // rename_file
    try {
      await renameFile(rootDirHandle, testFile, renamedFile);
      const ok = await exists(rootDirHandle, renamedFile);
      if (!ok) throw new Error('renamed file missing');
      log(fsLog, 'Rename PASS → ' + renamedFile);
      pass++;
    } catch (e) {
      log(fsLog, 'Rename FAIL: ' + e.message);
      fail++;
    }
    if (abort) return { pass, fail };
    // cleanup
    try {
      await removeEntry(rootDirHandle, renamedFile);
      log(fsLog, 'Cleanup PASS');
      pass++;
    } catch (e) {
      log(fsLog, 'Cleanup WARN (manual cleanup may be required): ' + e.message);
      // not marking as fail; be lenient
    }
    setStatus(fsStatus, fail ? ('Failed ('+fail+')') : 'Passed', fail ? 'fail' : 'pass');
    return { pass, fail };
  }

  async function runAll() {
    abort = false;
    runBtn.disabled = true;
    setStatus(backendStatus, 'Queued', 'warn');
    setStatus(fsStatus, 'Queued', 'warn');
    summaryText.textContent = 'Running...';
    const b = await runBackendTests();
    if (abort) { summaryText.textContent = 'Aborted.'; runBtn.disabled = false; return; }
    const f = await runFsTests();
    const totalPass = b.pass + f.pass;
    const totalFail = b.fail + f.fail;
    summaryText.textContent = 'Done. Passed: ' + totalPass + ', Failed: ' + totalFail + '.';
    runBtn.disabled = false;
  }

  runBtn.addEventListener('click', runAll);
  stopBtn.addEventListener('click', ()=> { abort = true; log(backendLog, 'Abort requested'); log(fsLog, 'Abort requested'); });
  selectDirBtn.addEventListener('click', async ()=> {
    try {
      rootDirHandle = await window.showDirectoryPicker();
      log(fsLog, 'Directory selected.');
      setStatus(fsStatus, 'Directory Ready', 'pass');
    } catch (e) {
      log(fsLog, 'Directory selection cancelled.');
    }
  });
})();
</script>
</body>
</html>