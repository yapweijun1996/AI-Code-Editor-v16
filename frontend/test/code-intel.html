<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Code Intelligence - Manual Indexing Test</title>
  <style>
    :root{
      --bg:#0f1115;--panel:#151820;--text:#e6e6e6;--muted:#9aa4b2;--accent:#3b82f6;--border:#232838;
    }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--text);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,"Apple Color Emoji","Segoe UI Emoji"}
    header{padding:16px 20px;border-bottom:1px solid var(--border);background:linear-gradient(180deg,rgba(59,130,246,0.12),transparent 60%)}
    h1{margin:0 0 6px;font-size:18px}
    .subtitle{color:var(--muted);font-size:13px}
    main{max-width:1200px;margin:0 auto;padding:16px}
    .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    .panel{background:var(--panel);border:1px solid var(--border);border-radius:10px;padding:12px}
    button{background:#238636;border:0;color:#fff;padding:8px 12px;border-radius:8px;cursor:pointer}
    button.secondary{background:#30363d}
    button:disabled{opacity:.6;cursor:not-allowed}
    input[type=text], input[type=number]{background:#0d1117;border:1px solid var(--border);color:var(--text);border-radius:8px;padding:8px 10px}
    .split{display:grid;grid-template-columns:320px 1fr;gap:12px}
    .list{height:480px;overflow:auto;background:#0d1117;border:1px solid var(--border);border-radius:8px}
    .list-item{padding:8px 10px;border-bottom:1px solid #1e2636;cursor:pointer}
    .list-item:hover{background:#0f1522}
    .meta{color:var(--muted);font-size:11px}
    .badge{display:inline-block;font-size:10px;padding:2px 6px;border-radius:999px;border:1px solid var(--border);color:var(--muted);margin-left:6px}
    .log{background:#0d1117;border:1px solid var(--border);border-radius:8px;padding:8px;height:140px;overflow:auto;font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;font-size:12px;white-space:pre-wrap}
    pre.code{background:#0d1117;border:1px solid var(--border);border-radius:8px;padding:10px;overflow:auto;max-height:480px}
    code, pre{color:#e6edf3}
    .search-row{display:flex;gap:8px;align-items:center;margin:8px 0}
    .stat{font-size:12px;color:var(--muted)}
    .hl{background:#402b00}
  </style>
</head>
<body>
  <header>
    <h1>Code Intelligence <span class="badge">Frontend Manual Indexing</span></h1>
    <div class="subtitle">Select a directory, index JS/TS files, list discovered symbols, and preview source locations. Uses the browser File System Access API and simple regex-based parsing (no backend).</div>
  </header>

  <main>
    <section class="panel">
      <div class="row">
        <button id="selectBtn">Select Directory</button>
        <button id="indexBtn" class="secondary" disabled>Index Code</button>
        <label>Max Depth: <input id="maxDepth" type="number" min="1" max="20" value="8" style="width:80px"></label>
        <label>Max File Size (KB): <input id="maxKB" type="number" min="1" max="10240" value="512" style="width:100px"></label>
        <span id="status" class="stat"></span>
      </div>
      <div class="row" style="margin-top:8px">
        <label>Include Patterns:</label>
        <input id="include" type="text" value="**/*.js,**/*.ts,**/*.jsx,**/*.tsx" style="min-width:360px">
        <label>Exclude Folders:</label>
        <input id="exclude" type="text" value="node_modules,.git,dist,build,out,.next,.cache" style="min-width:320px">
      </div>
    </section>

    <section class="split" style="margin-top:12px">
      <div>
        <div class="panel">
          <div class="search-row">
            <input id="search" type="text" placeholder="Filter symbols by name..." style="flex:1">
            <select id="kind">
              <option value="">All Kinds</option>
              <option value="function">function</option>
              <option value="class">class</option>
              <option value="method">method</option>
              <option value="const-fn">const-fn</option>
            </select>
          </div>
          <div class="stat" id="counts">Files: 0 • Symbols: 0</div>
        </div>
        <div id="symbolList" class="list"></div>
      </div>

      <div>
        <div class="panel">
          <div class="stat" id="detailMeta">Select a symbol to preview source around its definition.</div>
        </div>
        <pre id="preview" class="code"></pre>
      </div>
    </section>

    <section class="panel" style="margin-top:12px">
      <div>Log</div>
      <div id="log" class="log"></div>
    </section>
  </main>

<script>
(function(){
  const $ = s => document.querySelector(s);
  const logEl = $('#log');
  const selectBtn = $('#selectBtn');
  const indexBtn = $('#indexBtn');
  const maxDepthEl = $('#maxDepth');
  const maxKBEl = $('#maxKB');
  const includeEl = $('#include');
  const excludeEl = $('#exclude');
  const statusEl = $('#status');
  const symbolListEl = $('#symbolList');
  const countsEl = $('#counts');
  const searchEl = $('#search');
  const kindEl = $('#kind');
  const previewEl = $('#preview');
  const detailMetaEl = $('#detailMeta');

  let rootDirHandle = null;
  let filesIndex = []; // [{path, size, content?}]
  let symbols = [];    // [{name, kind, file, line, col, preview}]
  let filtered = [];

  function log(msg){
    const t = new Date().toISOString().split('T')[1].replace('Z','');
    logEl.textContent += '['+t+'] ' + msg + '\n';
    logEl.scrollTop = logEl.scrollHeight;
  }
  function setStatus(text){ statusEl.textContent = text || ''; }

  function splitCSV(v){
    return v.split(',').map(s => s.trim()).filter(Boolean);
  }

  async function walk(dirHandle, basePath, depth, maxDepth, excludeDirs){
    if (depth > maxDepth) return;
    for await (const [name, handle] of dirHandle.entries()){
      if (handle.kind === 'directory') {
        if (excludeDirs.has(name)) { continue; }
        await walk(await dirHandle.getDirectoryHandle(name), basePath + name + '/', depth+1, maxDepth, excludeDirs);
      } else {
        filesIndex.push({ path: basePath + name, handle });
      }
    }
  }

  function micromatchLike(path, patterns){
    // Very small glob check: supports **/*.ext and *.ext simple cases
    // For more complex matching, we can extend later.
    for (const p of patterns){
      if (p.startsWith('**/*.')) {
        const ext = p.slice(4); // '*.js'
        if (path.endsWith(ext.replace('*',''))) return true;
      } else if (p.startsWith('*.')) {
        if (path.endsWith(p.replace('*',''))) return true;
      } else if (p === path) {
        return true;
      }
    }
    return false;
  }

  function isIncluded(path, includePatterns, excludeDirs){
    // Exclude dir names anywhere in path
    for (const d of excludeDirs){
      if (path.split('/').includes(d)) return false;
    }
    return micromatchLike(path, includePatterns);
  }

  function extractSymbolsFromSource(src){
    const lines = src.split(/\r?\n/);
    const found = [];

    // Patterns
    const reFunction = /^\s*(?:export\s+)?function\s+([A-Za-z0-9_$]+)\s*\(/;
    const reClass = /^\s*(?:export\s+)?class\s+([A-Za-z0-9_$]+)\s*/;
    const reConstFn = /^\s*(?:export\s+)?(?:const|let|var)\s+([A-Za-z0-9_$]+)\s*=\s*(?:async\s+)?(?:function\s*\(|\([^\)]*\)\s*=>|[A-Za-z0-9_$]+\s*=>)/;
    const reMethod = /^\s*(?:async\s+)?([A-Za-z0-9_$]+)\s*\(([^\)]*)\)\s*{/; // naive; used inside class blocks

    // Simple pass: function / class / const-fn
    for (let i=0;i<lines.length;i++){
      const line = lines[i];
      let m;
      if ((m = reFunction.exec(line))) {
        found.push({ kind:'function', name:m[1], line:i+1, col:(line.indexOf(m[1])+1) });
      } else if ((m = reClass.exec(line))) {
        found.push({ kind:'class', name:m[1], line:i+1, col:(line.indexOf(m[1])+1), _classLine:i });
      } else if ((m = reConstFn.exec(line))) {
        found.push({ kind:'const-fn', name:m[1], line:i+1, col:(line.indexOf(m[1])+1) });
      }
    }

    // Naive class method detection: scan blocks after class lines until next class or end
    for (let i=0;i<found.length;i++){
      const item = found[i];
      if (item.kind !== 'class') continue;
      const start = item._classLine + 1;
      let braceDepth = 0;
      let inClass = false;
      for (let j=start;j<lines.length;j++){
        const L = lines[j];
        for (const ch of L){
          if (ch === '{') { braceDepth++; if (!inClass) inClass = true; }
          if (ch === '}') { braceDepth--; if (inClass && braceDepth<=0) { inClass=false; break; } }
        }
        if (!inClass && j>start) break;
        const mm = reMethod.exec(L);
        if (mm && inClass) {
          found.push({ kind:'method', name: item.name + '.' + mm[1], line:j+1, col:(L.indexOf(mm[1])+1) });
        }
      }
    }

    // Build previews
    for (const s of found){
      const start = Math.max(0, s.line-4);
      const end = Math.min(lines.length, s.line+3);
      const snippet = [];
      for (let i=start;i<end;i++){
        const ln = String(i+1).padStart(5,' ');
        let text = lines[i];
        if (i+1 === s.line) text = text.replace(s.name, '⟦' + s.name + '⟧');
        snippet.push(ln + '  ' + text);
      }
      s.preview = snippet.join('\n');
    }
    return found;
  }

  function renderList(items){
    symbolListEl.innerHTML = '';
    for (const it of items){
      const div = document.createElement('div');
      div.className = 'list-item';
      div.innerHTML = `
        <div><strong>${escapeHtml(it.name)}</strong> <span class="badge">${it.kind}</span></div>
        <div class="meta">${escapeHtml(it.file)} : line ${it.line}</div>
      `;
      div.onclick = () => showDetail(it);
      symbolListEl.appendChild(div);
    }
  }

  function showDetail(item){
    detailMetaEl.textContent = `${item.kind} ${item.name} — ${item.file}:${item.line}`;
    previewEl.textContent = item.preview || '';
  }

  function escapeHtml(str){
    // Properly escape HTML special characters for safe rendering
    const map = {
      '&': '&',
      '<': '<',
      '>': '>',
      '"': '"',
      "'": '&#39;'
    };
    return String(str).replace(/[&<>"']/g, ch => map[ch]);
  }

  function applyFilter(){
    const q = searchEl.value.trim().toLowerCase();
    const k = kindEl.value;
    filtered = symbols.filter(s => {
      if (k && s.kind !== k) return false;
      if (!q) return true;
      return s.name.toLowerCase().includes(q);
    });
    renderList(filtered);
  }

  async function indexCode(){
    if (!rootDirHandle) { log('Select a directory first.'); return; }

    indexBtn.disabled = true;
    setStatus('Walking directory...');
    log('---> Walk directory');
    filesIndex = [];

    const maxDepth = parseInt(maxDepthEl.value || '8', 10);
    const maxKB = parseInt(maxKBEl.value || '512', 10);
    const includePatterns = splitCSV(includeEl.value);
    const excludeDirs = new Set(splitCSV(excludeEl.value));

    await walk(rootDirHandle, '', 0, maxDepth, excludeDirs);

    // Filter & read
    setStatus('Reading files...');
    log(`Found ${filesIndex.length} entries, filtering includes/excludes...`);
    const candidates = filesIndex.filter(f => isIncluded(f.path, includePatterns, excludeDirs));
    log(`Candidates after filter: ${candidates.length}`);

    symbols = [];
    let readCount = 0;
    for (const f of candidates){
      try{
        const fh = await getFileHandleForPath(f.path);
        const file = await fh.getFile();
        const sizeKB = Math.round(file.size / 1024);
        if (sizeKB > maxKB) { continue; }
        const text = await file.text();
        const sym = extractSymbolsFromSource(text).map(s => ({...s, file: f.path}));
        symbols.push(...sym);
        readCount++;
        if (readCount % 20 === 0) setStatus(`Indexed ${readCount}/${candidates.length} files...`);
      }catch(e){
        log(`Read failed for ${f.path}: ${e.message}`);
      }
    }

    setStatus('Index complete.');
    countsEl.textContent = `Files: ${readCount} • Symbols: ${symbols.length}`;
    applyFilter();
    indexBtn.disabled = false;
  }

  async function getFileHandleForPath(pathStr){
    const parts = pathStr.split('/').filter(Boolean);
    let dir = rootDirHandle;
    for (let i=0;i<parts.length-1;i++){
      dir = await dir.getDirectoryHandle(parts[i], { create:false });
    }
    return await dir.getFileHandle(parts[parts.length-1], { create:false });
  }

  // Events
  selectBtn.addEventListener('click', async ()=>{
    try{
      rootDirHandle = await window.showDirectoryPicker();
      log('Directory selected.');
      indexBtn.disabled = false;
      setStatus('Directory ready');
    }catch(e){
      log('Directory selection cancelled.');
    }
  });

  indexBtn.addEventListener('click', indexCode);
  searchEl.addEventListener('input', applyFilter);
  kindEl.addEventListener('change', applyFilter);
})();
</script>
</body>
</html>