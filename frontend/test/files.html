<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Test: File System Tools (list_files, read_file, write_to_file, search_in_file, read_file_lines, rename_file)</title>
  <style>
    :root{
      --bg:#0f1115;--panel:#151820;--text:#e6e6e6;--muted:#9aa4b2;--accent:#3b82f6;--ok:#10b981;--warn:#f59e0b;--danger:#ef4444;--border:#232838;--code:#0b0e14;
    }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--text);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,"Apple Color Emoji","Segoe UI Emoji"}
    header{padding:20px;border-bottom:1px solid var(--border);background:linear-gradient(180deg,rgba(59,130,246,0.10),transparent 60%)}
    h1{margin:0 0 6px;font-size:20px}
    .subtitle{color:var(--muted);font-size:13px}
    main{max-width:1100px;margin:0 auto;padding:20px}
    a.back{display:inline-block;margin:8px 0 14px;color:#93c5fd;text-decoration:none;font-size:13px}
    a.back:hover{text-decoration:underline}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:16px}
    .panel{background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:16px}
    .panel h2{font-size:16px;margin:0 0 8px}
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-top:8px}
    .row input[type="text"], .row input[type="number"], .row textarea{
      background:#0f131c;border:1px solid var(--border);color:#e5e7eb;border-radius:8px;padding:8px;font-size:13px;width:100%
    }
    .row textarea{height:160px;resize:vertical}
    .row .half{flex:1 1 48%}
    .row .third{flex:1 1 30%}
    .btn{
      display:inline-block;text-decoration:none;border:1px solid rgba(59,130,246,0.35);
      background:rgba(59,130,246,0.15);color:#dbeafe;padding:8px 12px;border-radius:8px;font-size:14px;cursor:pointer
    }
    .btn:hover{background:rgba(59,130,246,0.25)}
    .btn-secondary{border-color:rgba(148,163,184,0.35);background:rgba(148,163,184,0.12);color:#e5e7eb}
    .btn-ok{border-color:rgba(16,185,129,0.4);background:rgba(16,185,129,0.15);color:#d1fae5}
    .btn-warn{border-color:rgba(245,158,11,0.4);background:rgba(245,158,11,0.15);color:#fde68a}
    .status{font-size:12px;margin-top:8px}
    .status.ok{color:#86efac}
    .status.err{color:#fca5a5}
    .code{
      background:var(--code);border:1px solid var(--border);border-radius:8px;padding:10px;
      white-space:pre-wrap;color:#cbd5e1;font-family:ui-monospace,Menlo,Consolas,monospace;font-size:12px
    }
    ul.tree{list-style:none;margin:0;padding-left:16px}
    ul.tree li{margin:2px 0}
    .file{color:#cbd5e1}
    .dir{color:#93c5fd}
    .note{color:var(--muted);font-size:12px;margin-top:8px}
    @media (max-width: 1100px){ .grid{grid-template-columns:1fr} }
  </style>
</head>
<body>
<header>
  <h1>File System Tools Test</h1>
  <div class="subtitle">Manual tests using the browser File System Access API: list_files, read_file, write_to_file, search_in_file, read_file_lines, and rename_file.</div>
</header>

<main>
  <a class="back" href="./index.html">&#8592; Back to Test Listing</a>

  <section class="panel" id="picker">
    <h2>Project Root</h2>
    <div class="row">
      <button id="btnPickRoot" class="btn">Choose Directory...</button>
      <button id="btnForgetRoot" class="btn btn-secondary">Forget Permission</button>
    </div>
    <div id="rootStatus" class="status">Root: not selected</div>
    <div class="note">
      This page uses the browser's File System Access API. Choose your project root directory to enable operations. Your permissions stay in the browser only.
    </div>
  </section>

  <div class="grid">
    <section class="panel" id="listPanel">
      <h2>list_files</h2>
      <div class="row">
        <input id="listPath" type="text" placeholder="Relative path (e.g., frontend/js). Leave empty for root."/>
        <button id="btnList" class="btn">List</button>
        <label class="note"><input type="checkbox" id="chkRecursive" checked/> Recursive</label>
      </div>
      <div id="listStatus" class="status"></div>
      <div id="listOutput" class="code" style="margin-top:8px;max-height:320px;overflow:auto"></div>
    </section>

    <section class="panel" id="readPanel">
      <h2>read_file</h2>
      <div class="row">
        <input id="readPath" type="text" placeholder="Relative file path (e.g., README.md)"/>
        <button id="btnRead" class="btn">Read</button>
      </div>
      <div id="readStatus" class="status"></div>
      <div id="readOutput" class="code" style="margin-top:8px;max-height:360px;overflow:auto"></div>
    </section>
  </div>

  <section class="panel" id="writePanel" style="margin-top:16px">
    <h2>write_to_file</h2>
    <div class="row">
      <div class="half">
        <input id="writePath" type="text" placeholder="Relative file path to write (e.g., tmp/test.txt)"/>
      </div>
      <div class="half" style="display:flex;gap:8px;justify-content:flex-end">
        <button id="btnWrite" class="btn btn-ok">Write (Create/Overwrite)</button>
        <button id="btnAppend" class="btn btn-warn">Append</button>
      </div>
    </div>
    <div class="row" style="margin-top:8px">
      <textarea id="writeContent" placeholder="Content to write or append..."></textarea>
    </div>
    <div id="writeStatus" class="status"></div>
  </section>

  <div class="grid" style="margin-top:16px">
    <section class="panel" id="searchPanel">
      <h2>search_in_file</h2>
      <div class="row">
        <input id="searchPath" type="text" placeholder="Relative file path (e.g., frontend/js/tool_executor.js)"/>
      </div>
      <div class="row">
        <input id="searchPattern" type="text" placeholder="Pattern to search (literal). For regex, toggle below."/>
      </div>
      <div class="row">
        <label class="note"><input type="checkbox" id="searchRegex"/> Use regex</label>
        <label class="note"><input type="checkbox" id="searchIgnoreCase" checked/> Ignore case</label>
      </div>
      <div class="row">
        <button id="btnSearch" class="btn">Search</button>
      </div>
      <div id="searchStatus" class="status"></div>
      <div id="searchOutput" class="code" style="margin-top:8px;max-height:340px;overflow:auto"></div>
      <div class="note">Displays matching lines with line numbers and a small context window.</div>
    </section>

    <section class="panel" id="linesPanel">
      <h2>read_file_lines</h2>
      <div class="row">
        <input id="linesPath" class="half" type="text" placeholder="Relative file path (e.g., README.md)"/>
        <input id="startLine" class="third" type="number" min="1" placeholder="Start line"/>
        <input id="endLine" class="third" type="number" min="1" placeholder="End line"/>
      </div>
      <div class="row">
        <button id="btnReadLines" class="btn">Read Lines</button>
      </div>
      <div id="linesStatus" class="status"></div>
      <div id="linesOutput" class="code" style="margin-top:8px;max-height:340px;overflow:auto"></div>
      <div class="note">Outputs the selected line range, inclusive.</div>
    </section>
  </div>

  <section class="panel" id="renamePanel" style="margin-top:16px">
    <h2>rename_file</h2>
    <div class="row">
      <input id="renameOld" class="half" type="text" placeholder="Old path (e.g., tmp/a.txt)"/>
      <input id="renameNew" class="half" type="text" placeholder="New path (e.g., tmp/b.txt)"/>
    </div>
    <div class="row">
      <button id="btnRename" class="btn btn-ok">Rename / Move</button>
    </div>
    <div id="renameStatus" class="status"></div>
    <div class="note">Implemented via copy+delete using the File System Access API to simulate rename/move.</div>
  </section>

  <!-- Folder Operations (Backend /api/execute-tool) -->
  <section class="panel" id="folderPanel" style="margin-top:16px">
    <h2>Folder Operations (Backend)</h2>
    <div class="note">These use the backend /api/execute-tool endpoint: create_folder, rename_folder, delete_folder.</div>

    <div class="row" style="margin-top:8px">
      <input id="createFolderPath" class="half" type="text" placeholder="Folder path (e.g., tmp/new-folder)"/>
      <button id="btnCreateFolder" class="btn btn-ok">Create Folder</button>
    </div>
    <div id="createFolderStatus" class="status"></div>

    <div class="row" style="margin-top:8px">
      <input id="renameFolderOld" class="half" type="text" placeholder="Old folder path (e.g., tmp/new-folder)"/>
      <input id="renameFolderNew" class="half" type="text" placeholder="New folder path (e.g., tmp/renamed-folder)"/>
    </div>
    <div class="row">
      <button id="btnRenameFolder" class="btn btn-ok">Rename Folder</button>
    </div>
    <div id="renameFolderStatus" class="status"></div>

    <div class="row" style="margin-top:8px">
      <input id="deleteFolderPath" class="half" type="text" placeholder="Folder path to delete (e.g., tmp/renamed-folder)"/>
      <button id="btnDeleteFolder" class="btn btn-warn">Delete Folder</button>
    </div>
    <div id="deleteFolderStatus" class="status"></div>
  </section>

  <!-- Auto Assertions for Folder Ops -->
  <section class="panel" id="folderAssertPanel" style="margin-top:16px">
    <h2>Folder Auto Assertions</h2>
    <div class="note">Performs the operation then calls get_project_structure to verify results.</div>

    <div class="row" style="margin-top:8px">
      <input id="aaCreatePath" class="half" type="text" placeholder="Folder path to create & assert"/>
      <button id="btnAACreate" class="btn">Create & Assert</button>
    </div>

    <div class="row" style="margin-top:8px">
      <input id="aaRenameOld" class="half" type="text" placeholder="Old folder path"/>
      <input id="aaRenameNew" class="half" type="text" placeholder="New folder path"/>
    </div>
    <div class="row">
      <button id="btnAARename" class="btn">Rename & Assert</button>
    </div>

    <div class="row" style="margin-top:8px">
      <input id="aaDeletePath" class="half" type="text" placeholder="Folder path to delete & assert"/>
      <button id="btnAADelete" class="btn btn-warn">Delete & Assert</button>
    </div>

    <div id="folderAssertLog" class="code" style="margin-top:8px;max-height:220px;overflow:auto"></div>
  </section>

  <section class="panel" id="logPanel" style="margin-top:16px">
    <h2>Log</h2>
    <div id="log" class="code" style="max-height:220px;overflow:auto"></div>
  </section>
</main>

<script>
(function(){
  let rootHandle = null;

  const el = id => document.getElementById(id);
  const log = (...args) => {
    const msg = args.map(a => typeof a === 'string' ? a : JSON.stringify(a, null, 2)).join(' ');
    const logEl = el('log');
    const at = new Date().toLocaleTimeString();
    logEl.textContent += '[' + at + '] ' + msg + '\\n';
    logEl.scrollTop = logEl.scrollHeight;
  };

  const setStatus = (id, text, type='') => {
    const s = el(id);
    s.textContent = text || '';
    s.className = 'status' + (type ? ' ' + type : '');
  };

  const showRoot = () => {
    setStatus('rootStatus', rootHandle ? 'Root: permission granted' : 'Root: not selected');
  };

  async function verifyPermission(handle, opts = { mode: 'readwrite' }) {
    if ((await handle.queryPermission(opts)) === 'granted') return true;
    if ((await handle.requestPermission(opts)) === 'granted') return true;
    return false;
  }

  async function getHandleFromPath(pathStr) {
    if (!rootHandle) throw new Error('Root not selected');
    const parts = pathStr.split('/').filter(Boolean);
    if (parts.length === 0) return rootHandle;

    let current = rootHandle;
    for (let i = 0; i < parts.length; i++) {
      const part = parts[i];
      const isLast = i === parts.length - 1;

      // Try as directory first
      try {
        current = await current.getDirectoryHandle(part);
        continue;
      } catch (_) {
        // Not a directory; try file if last
        if (isLast) {
          try {
            current = await current.getFileHandle(part);
            return current;
          } catch (e) {
            throw new Error('Path not found: ' + pathStr);
          }
        } else {
          throw new Error('Directory not found: ' + parts.slice(0, i+1).join('/'));
        }
      }
    }
    return current;
  }

  async function getDirectoryHandleFromParts(parts, create=false) {
    let current = rootHandle;
    for (const p of parts) {
      current = await current.getDirectoryHandle(p, { create });
    }
    return current;
  }

  async function ensureParentDirs(dirHandle, parts) {
    let current = dirHandle;
    for (const p of parts) {
      current = await current.getDirectoryHandle(p, { create: true });
    }
    return current;
  }

  async function listEntries(startHandle, recursive) {
    const results = [];
    async function walkDirectory(dirHandle, prefix) {
      for await (const entry of dirHandle.values()) {
        const fullPath = prefix ? prefix + '/' + entry.name : entry.name;
        if (entry.kind === 'file') {
          results.push({ type: 'file', path: fullPath });
        } else if (entry.kind === 'directory') {
          results.push({ type: 'dir', path: fullPath });
          if (recursive) {
            await walkDirectory(entry, fullPath);
          }
        }
      }
    }
    if (startHandle.kind === 'file') {
      results.push({ type: 'file', path: '' });
    } else {
      await walkDirectory(startHandle, '');
    }
    return results;
  }

  function renderTree(entries) {
    const sort = (a, b) => {
      if (a.type !== b.type) return a.type === 'dir' ? -1 : 1;
      return a.path.localeCompare(b.path);
    };
    entries.sort(sort);
    const lines = entries.map(e => (e.type === 'dir' ? '📁 ' : '📄 ') + e.path);
    return lines.join('\\n');
  }

  // Picker
  el('btnPickRoot').addEventListener('click', async () => {
    try {
      rootHandle = await window.showDirectoryPicker({ id: 'ai-ide-root' });
      const ok = await verifyPermission(rootHandle, { mode: 'readwrite' });
      if (!ok) throw new Error('Permission not granted');
      showRoot();
      log('Selected root directory.');
    } catch (e) {
      log('Failed to select root:', e.message || e);
      setStatus('rootStatus', 'Root selection failed: ' + (e.message || e), 'err');
    }
  });

  el('btnForgetRoot').addEventListener('click', async () => {
    // No standard way to revoke permissions programmatically.
    rootHandle = null;
    showRoot();
    log('Cleared root handle reference. To fully revoke, clear site data in your browser.');
  });

  // list_files
  el('btnList').addEventListener('click', async () => {
    setStatus('listStatus', '');
    el('listOutput').textContent = '';
    try {
      if (!rootHandle) throw new Error('Select a root directory first.');
      const rel = (el('listPath').value || '').trim();
      const recursive = el('chkRecursive').checked;
      log('list_files:', JSON.stringify({ path: rel || '.', recursive }));

      let startHandle = rootHandle;
      if (rel) {
        const parts = rel.split('/').filter(Boolean);
        let current = rootHandle;
        for (const p of parts) {
          current = await current.getDirectoryHandle(p);
        }
        startHandle = current;
      }

      const entries = await listEntries(startHandle, recursive);
      el('listOutput').textContent = renderTree(entries);
      setStatus('listStatus', `Listed ${entries.length} entries`, 'ok');
    } catch (e) {
      setStatus('listStatus', e.message || String(e), 'err');
      log('list_files error:', e.message || e);
    }
  });

  // read_file
  el('btnRead').addEventListener('click', async () => {
    setStatus('readStatus', '');
    el('readOutput').textContent = '';
    try {
      if (!rootHandle) throw new Error('Select a root directory first.');
      const filePath = (el('readPath').value || '').trim();
      if (!filePath) throw new Error('Please enter a relative file path to read.');
      log('read_file:', JSON.stringify({ filename: filePath }));

      const parts = filePath.split('/').filter(Boolean);
      let current = rootHandle;
      for (let i = 0; i < parts.length - 1; i++) {
        current = await current.getDirectoryHandle(parts[i]);
      }
      const fh = await current.getFileHandle(parts[parts.length - 1]);
      const file = await fh.getFile();
      const text = await file.text();

      el('readOutput').textContent = text;
      setStatus('readStatus', `Read ${file.size} bytes`, 'ok');
    } catch (e) {
      setStatus('readStatus', e.message || String(e), 'err');
      log('read_file error:', e.message || e);
    }
  });

  // write_to_file / append
  el('btnWrite').addEventListener('click', async () => {
    await writeInternal(false);
  });
  el('btnAppend').addEventListener('click', async () => {
    await writeInternal(true);
  });

  async function writeInternal(append) {
    setStatus('writeStatus', '');
    try {
      if (!rootHandle) throw new Error('Select a root directory first.');
      const filePath = (el('writePath').value || '').trim();
      const content = el('writeContent').value ?? '';
      if (!filePath) throw new Error('Please enter a relative file path to write.');
      log(append ? 'append_to_file:' : 'write_to_file:', JSON.stringify({ filename: filePath, contentPreview: content.slice(0, 80) + (content.length > 80 ? '…' : '') }));

      const parts = filePath.split('/').filter(Boolean);
      const filename = parts.pop();
      const parent = await ensureParentDirs(rootHandle, parts);
      const fh = await parent.getFileHandle(filename, { create: true });

      let newContent = content;
      if (append) {
        try {
          const existing = await (await fh.getFile()).text();
          newContent = existing + content;
        } catch (_) {
          // If doesn't exist or unreadable, just write new content
        }
      }

      const writable = await fh.createWritable();
      await writable.write(newContent);
      await writable.close();

      setStatus('writeStatus', append ? 'Append successful' : 'Write successful', 'ok');
    } catch (e) {
      setStatus('writeStatus', e.message || String(e), 'err');
      log('write_to_file error:', e.message || e);
    }
  }

  // Helpers for search/lines/rename
  async function getDirectoryHandleFromParts(parts, create=false) {
    let current = rootHandle;
    for (const p of parts) {
      current = await current.getDirectoryHandle(p, { create });
    }
    return current;
  }
  async function getFileHandleByPath(pathStr, create=false) {
    const parts = pathStr.split('/').filter(Boolean);
    if (parts.length === 0) throw new Error('Invalid path');
    const filename = parts.pop();
    const parent = await getDirectoryHandleFromParts(parts, create);
    const fh = await parent.getFileHandle(filename, { create });
    return fh;
  }
  function toLines(text) {
    return text.replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n').split('\\n');
  }

  // search_in_file
  el('btnSearch').addEventListener('click', async () => {
    setStatus('searchStatus', '');
    el('searchOutput').textContent = '';
    try{
      if (!rootHandle) throw new Error('Select a root directory first.');
      const filePath = (el('searchPath').value || '').trim();
      const pattern = (el('searchPattern').value || '').trim();
      const useRegex = el('searchRegex').checked;
      const ignoreCase = el('searchIgnoreCase').checked;
      if (!filePath) throw new Error('Please enter a file path.');
      if (!pattern) throw new Error('Please enter a pattern.');

      log('search_in_file:', JSON.stringify({ filename: filePath, pattern, useRegex, ignoreCase }));
      const fh = await getFileHandleByPath(filePath, false);
      const text = await (await fh.getFile()).text();
      const lines = toLines(text);

      let matcher;
      if (useRegex) {
        const flags = ignoreCase ? 'i' : '';
        matcher = (s) => new RegExp(pattern, flags).test(s);
      } else {
        const needle = ignoreCase ? pattern.toLowerCase() : pattern;
        matcher = (s) => (ignoreCase ? s.toLowerCase() : s).includes(needle);
      }

      const context = 1;
      const out = [];
      for (let i = 0; i < lines.length; i++) {
        if (matcher(lines[i])) {
          const start = Math.max(0, i - context);
          const end = Math.min(lines.length - 1, i + context);
          for (let j = start; j <= end; j++) {
            out.push(String(j+1).padStart(5, ' ') + ' | ' + lines[j]);
          }
          out.push('-----');
        }
      }
      el('searchOutput').textContent = out.length ? out.join('\\n') : '(no matches)';
      setStatus('searchStatus', 'Search completed', 'ok');
    }catch(e){
      setStatus('searchStatus', e.message || String(e), 'err');
      log('search_in_file error:', e.message || e);
    }
  });

  // read_file_lines
  el('btnReadLines').addEventListener('click', async () => {
    setStatus('linesStatus', '');
    el('linesOutput').textContent = '';
    try{
      if (!rootHandle) throw new Error('Select a root directory first.');
      const filePath = (el('linesPath').value || '').trim();
      const sLine = parseInt(el('startLine').value, 10);
      const eLine = parseInt(el('endLine').value, 10);
      if (!filePath) throw new Error('Please enter a file path.');
      if (!Number.isFinite(sLine) || !Number.isFinite(eLine) || sLine < 1 || eLine < sLine) {
        throw new Error('Please provide valid start and end line numbers (1-based, end >= start).');
      }

      log('read_file_lines:', JSON.stringify({ filename: filePath, start_line: sLine, end_line: eLine }));
      const fh = await getFileHandleByPath(filePath, false);
      const text = await (await fh.getFile()).text();
      const lines = toLines(text);

      const startIdx = Math.max(0, Math.min(lines.length, sLine) - 1);
      const endIdx = Math.max(0, Math.min(lines.length, eLine) - 1);
      const out = [];
      for (let i = startIdx; i <= endIdx; i++) {
        out.push(String(i+1).padStart(5, ' ') + ' | ' + lines[i]);
      }
      el('linesOutput').textContent = out.length ? out.join('\\n') : '(no lines in range)';
      setStatus('linesStatus', `Read lines ${sLine}-${eLine}`, 'ok');
    }catch(e){
      setStatus('linesStatus', e.message || String(e), 'err');
      log('read_file_lines error:', e.message || e);
    }
  });

  // rename_file (copy + delete)
  el('btnRename').addEventListener('click', async () => {
    setStatus('renameStatus', '');
    try{
      if (!rootHandle) throw new Error('Select a root directory first.');
      const oldPath = (el('renameOld').value || '').trim();
      const newPath = (el('renameNew').value || '').trim();
      if (!oldPath || !newPath) throw new Error('Please provide both old and new paths.');
      if (oldPath === newPath) throw new Error('Old and new paths are identical.');

      log('rename_file:', JSON.stringify({ old_path: oldPath, new_path: newPath }));

      // Read old file
      const oldFH = await getFileHandleByPath(oldPath, false);
      const oldBlob = await (await oldFH.getFile()).text();

      // Ensure parent dirs for new path
      const parts = newPath.split('/').filter(Boolean);
      const filename = parts.pop();
      const parent = await getDirectoryHandleFromParts(parts, true);
      const newFH = await parent.getFileHandle(filename, { create: true });

      // Write content to new file
      const writable = await newFH.createWritable();
      await writable.write(oldBlob);
      await writable.close();

      // Delete old file
      const oldParts = oldPath.split('/').filter(Boolean);
      const oldName = oldParts.pop();
      const oldParent = await getDirectoryHandleFromParts(oldParts, false);
      await oldParent.removeEntry(oldName);

      setStatus('renameStatus', 'Rename completed', 'ok');
    }catch(e){
      setStatus('renameStatus', e.message || String(e), 'err');
      log('rename_file error:', e.message || e);
    }
  });

  // Backend tool helpers for folder ops
  async function beCallTool(tool, args) {
    const payload = { tool, args };
    log('beCallTool:', JSON.stringify(payload));
    const res = await fetch('/api/execute-tool', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });
    const text = await res.text();
    let data;
    try { data = JSON.parse(text); } catch { data = { raw: text }; }
    log('beCallTool response:', JSON.stringify({ status: res.status, data }));
    if (!res.ok) throw new Error((data && (data.error || data.message)) || ('HTTP ' + res.status));
    return data;
  }

  async function beGetProjectStructure() {
    try {
      const res = await fetch('/api/execute-tool', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ tool: 'get_project_structure', args: {} })
      });
      const text = await res.text();
      let data;
      try { data = JSON.parse(text); } catch { data = { raw: text }; }
      return data.structure || data.raw || JSON.stringify(data);
    } catch (e) {
      return '';
    }
  }

  function pathExistsInTree(treeText, path) {
    if (!treeText) return false;
    const normalized = String(treeText).replace(/\\\\/g, '/').replace(/\\/g, '/');
    const check = String(path).replace(/\\\\/g, '/').replace(/\\/g, '/');
    // Match on path boundaries to reduce false positives
    const pattern = new RegExp('(^|[\\n\\r\\/])' + check.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\$&') + '(\\/|\\n|\\r|$)');
    return pattern.test(normalized);
  }

  function setBtnBusy(btn, busy) {
    if (!btn) return;
    btn.disabled = !!busy;
    btn.textContent = btn.dataset.label || btn.textContent;
    if (busy) {
      if (!btn.dataset.label) btn.dataset.label = btn.textContent;
      btn.textContent = 'Working...';
    }
  }

  // Wire folder create
  document.getElementById('btnCreateFolder')?.addEventListener('click', async (ev) => {
    const btn = ev.currentTarget;
    const path = (document.getElementById('createFolderPath').value || '').trim();
    const statusEl = document.getElementById('createFolderStatus');
    statusEl.textContent = '';
    if (!path) { statusEl.textContent = 'Please enter a folder path.'; statusEl.className = 'status err'; return; }
    try {
      setBtnBusy(btn, true);
      await beCallTool('create_folder', { path });
      statusEl.textContent = 'Folder created'; statusEl.className = 'status ok';
    } catch (e) {
      statusEl.textContent = e.message || String(e); statusEl.className = 'status err';
    } finally {
      setBtnBusy(btn, false);
    }
  });

  // Wire folder rename
  document.getElementById('btnRenameFolder')?.addEventListener('click', async (ev) => {
    const btn = ev.currentTarget;
    const oldPath = (document.getElementById('renameFolderOld').value || '').trim();
    const newPath = (document.getElementById('renameFolderNew').value || '').trim();
    const statusEl = document.getElementById('renameFolderStatus');
    statusEl.textContent = '';
    if (!oldPath || !newPath) { statusEl.textContent = 'Provide old and new folder paths.'; statusEl.className = 'status err'; return; }
    try {
      setBtnBusy(btn, true);
      await beCallTool('rename_folder', { oldPath, newPath });
      statusEl.textContent = 'Folder renamed'; statusEl.className = 'status ok';
    } catch (e) {
      statusEl.textContent = e.message || String(e); statusEl.className = 'status err';
    } finally {
      setBtnBusy(btn, false);
    }
  });

  // Wire folder delete
  document.getElementById('btnDeleteFolder')?.addEventListener('click', async (ev) => {
    const btn = ev.currentTarget;
    const path = (document.getElementById('deleteFolderPath').value || '').trim();
    const statusEl = document.getElementById('deleteFolderStatus');
    statusEl.textContent = '';
    if (!path) { statusEl.textContent = 'Please enter a folder path.'; statusEl.className = 'status err'; return; }
    if (!confirm('Delete folder and contents?')) { statusEl.textContent = 'Cancelled'; statusEl.className = 'status'; return; }
    try {
      setBtnBusy(btn, true);
      await beCallTool('delete_folder', { path });
      statusEl.textContent = 'Folder deleted'; statusEl.className = 'status ok';
    } catch (e) {
      statusEl.textContent = e.message || String(e); statusEl.className = 'status err';
    } finally {
      setBtnBusy(btn, false);
    }
  });

  // Auto-assert logs
  const aaLog = (...args) => {
    const msg = args.map(a => typeof a === 'string' ? a : JSON.stringify(a)).join(' ');
    const elOut = document.getElementById('folderAssertLog');
    const at = new Date().toLocaleTimeString();
    if (elOut) {
      elOut.textContent += '[' + at + '] ' + msg + '\\n';
      elOut.scrollTop = elOut.scrollHeight;
    }
    log('[AA]', msg);
  };

  async function aaCreate(path) {
    aaLog('Create & Assert start:', path);
    await beCallTool('create_folder', { path });
    await new Promise(r => setTimeout(r, 500));
    const tree = await beGetProjectStructure();
    const ok = pathExistsInTree(tree, path);
    aaLog('Create & Assert result:', ok ? 'FOUND (ok)' : 'NOT FOUND');
  }

  async function aaRename(oldPath, newPath) {
    aaLog('Rename & Assert start:', oldPath, '->', newPath);
    await beCallTool('rename_folder', { oldPath, newPath });
    await new Promise(r => setTimeout(r, 500));
    const tree = await beGetProjectStructure();
    const oldExists = pathExistsInTree(tree, oldPath);
    const newExists = pathExistsInTree(tree, newPath);
    aaLog('Rename & Assert result:', 'old:', oldExists ? 'STILL FOUND' : 'NOT FOUND (ok)', '; new:', newExists ? 'FOUND (ok)' : 'NOT FOUND');
  }

  async function aaDelete(path) {
    aaLog('Delete & Assert start:', path);
    await beCallTool('delete_folder', { path });
    await new Promise(r => setTimeout(r, 500));
    const tree = await beGetProjectStructure();
    const still = pathExistsInTree(tree, path);
    aaLog('Delete & Assert result:', still ? 'STILL FOUND (failed)' : 'NOT FOUND (ok)');
  }

  document.getElementById('btnAACreate')?.addEventListener('click', (ev) => {
    const p = (document.getElementById('aaCreatePath').value || '').trim();
    if (!p) { aaLog('auto-create: missing path'); return; }
    aaCreate(p);
  });
  document.getElementById('btnAARename')?.addEventListener('click', (ev) => {
    const o = (document.getElementById('aaRenameOld').value || '').trim();
    const n = (document.getElementById('aaRenameNew').value || '').trim();
    if (!o || !n) { aaLog('auto-rename: missing old/new'); return; }
    aaRename(o, n);
  });
  document.getElementById('btnAADelete')?.addEventListener('click', (ev) => {
    const p = (document.getElementById('aaDeletePath').value || '').trim();
    if (!p) { aaLog('auto-delete: missing path'); return; }
    if (!confirm('Delete folder and contents?')) { aaLog('auto-delete: cancelled'); return; }
    aaDelete(p);
  });

  // Initialize
  showRoot();
})();
</script>
</body>
</html>